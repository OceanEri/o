{"pages":[{"title":"","text":"今天的优化可以是明日的累赘 职场不是学校，如果感受到疼痛，记住这个感觉，做的更好，避免在同一块石头上摔两次 简单地说，生物进化之前还有化学进化。 然而细胞一经诞生，中心法则的分子进化就趋于停滞了：38亿年来，中心法则再没有新的变动，所有的蛋白质都由 20 种标准氨基酸连成，连碱基与氨基酸对应关系也沿袭至今，所有现代生物共用一套标准遗传密码。 正如中心法则是化学进化的产物，却因为开创了生物进化而停止了化学进化，人类是生物进化的产物，也因为开创了文化进化和技术进化而停止了生物进化——进化已经走上了更高的维度。 – 《进化的阶次 | 混乱博物馆》","link":"/o/about/index.html"},{"title":"游啊游","text":"自由泳腿脚要内扣 侧身打腿要点：脑袋不要转，身体绷直侧起来，主动转动身体。 转体要点： 头、屁股不要动，转动身体（表现为带动肩膀） 练习方式： 对柱转体 对镜子转体 打腿和转体的配合 （水中练习）练习方式： 两个腿分开一点！找找感觉，左肩起左腿下去，右肩起右肩膀起来。 侧身打腿加转体","link":"/o/swim/index.html"},{"title":"","text":"// reduce 非常强大 map、filter、forEach 函数都可以使用 reduce 实现 // 使用 reduce 模拟 map 函数 /** * map 的使用方法 * [1,2,3,4].map(item => { * console.log(item) * }) */ const map = (fn, arr) => arr.reduce((acc, item, index, arr) => { return acc.concat(fn(item, index, arr)) }, []) // 使用 reduce 实现 filter /** * filter 的使用方法 * [1,2,3,4].filter(item => { * return item > 2 * }) * * > 3, 4 */ // filter 中的判断函数称为 predicate function const filter = (fn, arr) => (newArr, item) => { return fn(item) ? newArr.concat(item) : newArr // predicate function } // 使用 reduce 实现 forEach // 使用 reduce 实现 reduceRight // 使用 reduce 实现 compose /** * compose(f, g, h) * f, g, h => f(g(h(x))) */ const compose = (...fn) => x => fn.reduceRight((v, f) => f(v), x) // 使用 reduce 实现 pipe 函数 /** * pipe(h, g, f) * f(g(h(x))) */ const pipe = (...fn) => fn.reduce((v, f) => f(v), x) /** * 同一性 * f.map(x => x) == f */ /** * 组合性 * const r1 = u.map(x => f(g(x))); * const r2 = u.map(g).map(f); * * r1.map(trace); // 5 * r2.map(trace); // 5 */ // MDN 迭代协议 class Maybe { constructor(value) { this.value } map (fn) { return this.value ? Maybe.of(fn(this.value)) : Maybe.of(null) } } Maybe.of = function (value) { return new Maybe(value) } // Monald 函子 // 实现 filter const selfFilter = (arr, callback) => arr.reduce((newArr, item) => { return callback(item) ? newArr.push(item) : newArr }) // 实现 map const selfMap = (arr, fn) => arr.reduce((newArr, item) => { return newArr.push(fn(arr)) }) const pipe = (...fn) => x => fn.reduce((v, f) => f(v), x) const compose = (...fn) => x => fn.reduceRight((v, f) => f(v), x) const getAccu = (...agrs) => agrs.reduce((accu, item) => accu + item, 0)","link":"/o/test/index.js"},{"title":"","text":"class Functor { constructor(value) { this.value = value } map(fn) { return Functor.of(fn(this.value)) } static of(value) { return new Functor(value) } } let add = value => value + 1 let doubleAdd = value => value + 2 let multiply = value => value * value Functor.of(1).map(add).map(doubleAdd).map(multiply) // 构造 Promise 的 Functor 函子 document.getElementById(\"login\").addEventListener(\"click\", submitL); //eventlistener for login function submitL() { var loginInfo = {} loginInfo.email = document.getElementById.(\"email\").value; loginInfo.password = document.getElementById.(\"password\").value; var ss = SpreadsheetApp.openById(\"15rUIxS8w53bvPZvTKuOdGw-ZP6eWMaykVJ26vqGBkEg\"); var ws = ss.getSheetByName(\"logindet\"); var loginList = ws.getRange(2, 1, ws.getLastRow() - 1, 3).getValues(); var email = loginList.map(function (r) { return r[0] }); var password = loginList.map(function (r) { return r[1] }); var viewNameData = loginList.map(function (r) { return r[2] }); var loginEmail = loginInfo.email; var loginPW = loginInfo.password; for (var i = 0; i < email.length; i++) { if ((loginEmail == email[i]) && (loginPW == password[i])) { document.getElementById(\"load\").click(); } } }","link":"/o/test/promise.js"}],"posts":[{"title":"写在2020年之初-工作两年半的想法","text":"当你老了，回顾一生，就会发觉：什么时候出国读书，什么时候决定做第一份职业、何时选定了对象而恋爱、什么时候结婚，其实都是命运的巨变。只是当时站在三岔路口，眼见风云千樯，你作出选择的那一日，在日记上，相当沉闷和平凡，当时还以为是生命中普通的一天。 系统\b而深入的获取知识衡量程序\b员优劣的其中一个维度是基础是否牢固。\b你想摆脱简单的重复性劳动去负责更重要的模块基础这块是无法避免的。 js 中的 Promise 原理\b了解 FRP 才能理解的更深入；vue 的 keep-alive 组件使用了 LRU 算法；模板编译 client-server 模型是 web 开发的理论依据， 你对他掌握的如何取决于你\b自身网络协议的功底；AST (abstract syntax tree) 是编译\b原理中的理论、\b对操作系统了解的不够\b不管你写什么后端语言，\b\b也只会是个接口开发人员。 2020 年减少碎片化信息的获取，碎片化信息可以作为一个了解知识的入口但不能\b直接靠他来提升技能，\b利用业余时间\b看书或者线上 MOOC 的方式去系统的获取知识。也是避免 提前工作 ( overworking ) 情况\b的发生。 \b过度工作（overworking）：\b劳动者提前透支自己的技能，被工作拖着走\b，\b这种情况下主观能动性会收到很大影响。 输出意识来北京之后学到的最重要的一点一定是「输出意识」。在技术论坛里看过的不代表自己理解\b掌握了，\b提高这些碎片化知识的转化率需要个人记录和实践，眼睛觉得看到的东西很简单、\b可是手不这么认为。\b「输出意识」的具体表现为文档、博客、一段\b验证性质的\b代码片段\b；甚至可以为自己吃过的某道菜和看过的电影和书籍都可以\b\b写自己的评价。 业务目前自己负责的\b工作后接触到的业务方向一直是 B 端，基本上写了两年多的 web 页面，主要类型是复杂的 web 中后台系统。实际上业务是千变万化的，自己的学习重点要放在数据流的处理方式、流行框架的工作机制上。一方面要寻求更大的业务挑战，三年是一个槛如果目前的工作环境无法满足自己的需求那么就要考虑跳槽。另一方面探索 low code 这种业务处理模式，类似 uform、formRender 的表单处理方案。 \b目前不是自己负责的但接触很多的\b自己的第一家公司规模比较大，基础技术设施比较完备，所以可以只专心做一个系统甚至一个模块的\b开发，专注于开发语言本身。来到 Keep 后\b情况就大不同，年轻公司的基础技术平台建设几乎为零，自己\b也直接或间接的参与了\b公司的基础技术平台建设，从 SSO、BFF 代理服务到CI CD 平台、前端研发体系、全链路压测平台、运维体系、复杂工单的流转平台等等。 虚荣指标虚荣指标对自己目标的达成有一定促进意义，\b所以 2020 年也给自己定几个虚荣指标督促自己： 1、 每天看书 计划 《SICP》已完成 3 0 页（\b\bJavaScript 语言的开发者是 scheme 的狂热粉丝， SICP 曾是很多高校的基础读物，其中使用lisp 的一种方言 scheme 语言来教学， 可以提升对不同编程语言的系统性认识） 2、 学习一门新的编程语言（主要应用在 server） 把 Java Spring Boot 应用在业务中，\b有条件就做起来。 3、 坚持每周刷题 leetcode 「拳不留手，曲不离口」养家糊口的技能不能怠慢。 4、 github 每月活跃 &gt;= 28 天 纯粹的\b虚荣指标 5、 坚持写博客，持续输出 可以当作个人的 OKR。 6、减少焦虑、理性看待各种博文。","link":"/o/2020/01/01/2019/"},{"title":"如何理解函数式编程","text":"要回答这个问题，需要\b知道什么是编程范式。 编程范式函数式编程范式是一种 编程范式。我们通常见到的编程\b范式有 命令式编程(Imperative programming)、函数式编程 和 逻辑式编程，面向\b对象编程也属于命令式编程的一种。 \b命令式编程命令式编程是面向计算机\b硬件的抽象，有变量（对应着存储单元）、赋值语句（获取指令和存储指令），表达式（内存引用）和\b控制语句（跳转指令）。\b总而言之，\b命令式编程就是一个冯诺伊曼机的\b\b指令序列**。 函数式编程的本质而函数式编程是面向数学的抽象，将计算描述为一种表达式值，\b可以这么说：一个函数就是\b一个表达式值 函数式编程中的函数这个术语不是\b说计算机中的函数（实际上为 Subroutine，而是指数学中的函数，也就是自变量的映射。也就是说\b一个函数的值仅决定于函数参数的值，不依赖其他状态。比如 sqrt(x)函数计算x的平方根，只要 x 不变，无论何时调用，调用几次值都是不变的。 在函数式语言中，函数作为一等公民，可以在任何地方定义，在函数内或函数外，\b可以作为函数的参数和返回值，\b可以对函数进行\b组合。 纯函数\b\b式编程中的变量也不是命令式编程中的变量，即存储状态\b状态的单元，而是\b\b代数中的变量，即一个值的名称。变量的值是不可变的（immutable），也就是说\b不允许像命令\b\b式编程\b语言中的那样多次给一个变量赋值。 例如 在命令式\b编程\b语言中我们写的“x = x + 1”，这依赖可变状态的事实，拿给\b程序看是正确的，但是拿给数学家看\b\b，却被认为这个等式为假。 函数式语言的如条件语句，循环语句也不是命令式编程语言中的控制语句，而是函数式编程中的语法糖。 严格意思上的函数式\b编程意味着不使用可变的变量，赋值，循环和其他命令式结构进行编程。 从理论上说，函数式语言也不是通过冯诺伊曼体系结构的机器上运行的，而是通过λ演算来运行的，就是通过变量替换的方式进行，变量替换为其值或表达式，函数也替换为其表达式，并根据运算符进行计算。λ演算是图灵完全（Turing completeness）的，但是大多数情况，函数式程序还是被编译成（冯诺依曼机的）机器语言的指令执行的。 函数式编程的好处由于命令式编程语言也可以通过类似函数指针的方式来实现高阶函数，函数式的最主要的好处主要是不可变性带来的。没有可变的状态，函数就是引用透明（Referential transparency）的和没有副作用（No Side Effect）。\b一个好处是，函数即不依赖外部的状态也不修改外部的状态，函数调用的结果不依赖调用的时间和位置，这样写的代码容易进行推理，不容易出错。这使得单元测试和调试都更容易。 由于函数是引用透明的，以及函数式编程不像命令式编程那样关注执行步骤，这个系统提供了优化函数式程序的空间，包括惰性求值和并性处理。 还有一个好处是，由于函数式语言是面向数学的抽象，更接近人的语言，而不是机器语言，代码会比较简洁，也更容易被理解。 函数式编程的特性由于变量值是不可变的，对于值的操作并不是修改原来的值，而是修改新产生的值，原来的值保持不便。例如一个Point类，其moveBy方法不是改变已有Point实例的x和y坐标值，而是返回一个新的Point实例。 1234567class Point(x: Int, y: Int)&#123; override def toString() = \"Point (\" + x + \", \" + y + \")\" def moveBy(deltaX: Int, deltaY: Int) = &#123; new Point(x + deltaX, y + deltaY) &#125;&#125;（示例来源：Anders Hejlsberg在echDays 2010上的演讲） 同样由于变量不可变，纯函数编程语言无法实现循环，这是因为for循环使用可变的状态作为计数器，而While循环或DoWhile循环需要可变的状态作为跳出循环的条件。因此在函数式语言里就只能使用递归来解决迭代问题，这使得函数式编程严重依赖递归。 通常来说，算法都有 递推 (iterative) 和 递归（recursive) 两种定义，以阶乘为例，阶乘的递推定义为： 阶乘的定义为 递推定义的计算时需要使用一个累积器保存每个迭代的中间计算结果，Java代码如下： 1234567public static int fact(int n)&#123; int acc = 1; for(int k = 1; k &lt;= n; k++)&#123; acc = acc * k; &#125; return acc;&#125;而递归定义的计算的Scala代码如下： 1234def fact(n: Int):Int= &#123; if(n == 0) return 1 n * fact(n-1)&#125; 我们可以看到，没有使用循环，没有使用可变的状态，函数更短小，不需要显示地使用累积器保存中间计算结果，而是使用参数n（在栈上分配）来保存中间计算结果。 当然，这样的递归调用有更高的开销和局限（调用栈深度），那么尽量把递归写成尾递归的方式，编译器会自动优化为循环。 一般来说，递归这种方式于循环相比被认为是更符合人的思维的，即告诉机器做什么，而不是告诉机器怎么做。递归还是有很强大的表现力的。 函数式语言中的特性 \b高阶函数（High-order function） 偏函数（Particial Applied function） \b\bCurrying 闭包 （closure） 惰性求值 （Lazy evaluation）、（call by need） \b高阶函数 123function sum(funcA, funcB, value) &#123; return funcA(value) + funcB(value)&#125; 偏函数 偏函数则是固定一个函数的一个或者多个参数，也就是将一个 n 元函数转换成一个 n - x 元函数 偏函数和 currying 有一定的联系 引用 functional-programming-jargon 的话来说就是： Curried functions are automatically partially applied. 1234567891011function add(a, b) &#123; return a + b&#125;// \b计算\b a、b 的和add(a, b)// 使用偏函数var addOne = partial(add, 1)addOne(2) Currying 12345678910function add(a, b) &#123; return a + b;&#125;// 执行 add 函数，一次传入两个参数即可add(1, 2) // 3// 假设有一个 curry 函数可以做到柯里化var addCurry = curry(add);addCurry(1)(2) // 3 4.惰性求值 1234var a = function (b) &#123; return b&#125;a(3) \b总结函数式编程是给软件开发者提供的另一套工具箱，为我们提供了另外一种抽象和思考的方式。 函数式编程也有不太擅长的场合，比如处理可变状态和处理IO，要么引入可变变量，要么通过Monad来进行封装（如State Monad和IO Monad） 参考资料 本文大部分都参考了这篇文章：\b如何理解函数式编程 \b中「用心阁」的回答 [] 知乎 17点的回答 JavaScript专题之函数柯里化 掘金翻译：Functor 与 Category （软件编写）（第六部分） \b其他等待理解的 图灵机完备 lamda \b演算 \bSICP Haskell Monald","link":"/o/2019/12/10/Functional/"},{"title":"JS 模块加载器原理","text":"参考 JS模块加载器加载原理是怎么样的？","link":"/o/2019/12/25/JS-module/"},{"title":"How does the “this” keyword work?","text":"最近在 stackoverflow 看到了一个问题: this 是如何工作的。要想解释这个问题，需要对 JavaScript Exuction 和 JavaScript Scope 有足够的了解。 按照 JavaScript Specification Initial global execution context Entering eval code Entering function code Arrow function Arrow functions don’t have their own this…. binding. Instead, those identifiers are resolved in the lexical scope like any other variable. That means that inside an arrow function, this…refer(s) to the values of this in the environment the arrow function is defined in. How does the “this” keyword work?","link":"/o/2019/12/26/JavaScript-Excution/"},{"title":"JavaScript 原型链机制","text":"Flag: 使用 canvas 技术将其可视化出来","link":"/o/2019/12/25/JavaScript-chain/"},{"title":"JavaScript 中的原型污染攻击","text":"参考： 深入理解 JavaScript Prototype 污染攻击 prototype-pollution-nsec18 JavaScript 原型链污染 从一道 CTF 题看 Node.js 的 prototype pollution attack","link":"/o/2019/12/25/JavaScript-pollution/"},{"title":"升级 Node 遇到的一些问题","text":"今天在将 node 从 8.6.0 升级到 node 12.0.4 时候遇到这么一个问题: 这是因为 gnulib glib 和 glibc 的版本过低导致的，那么问题来了 gnulib glib 和 glibc 分别指的什么呢 ？ 答： glibc 是一个 C 语言 运行时库, 例如 printf(3) fopen(3) 答： glib 是一个基于 C 语言的工具库，同时也是一个面向对象的事件循环 答： gnulib 是一个适配 POSIX API 和 native API 的库。 那么问题又来了，到底什么是 runtime library 呢？ 答: 运行时库就是程序运行的时候所需要依赖的库。运行时库就是程序运行的时候所需要依赖的库。运行的时候指的是指令加载到内存并由CPU执行的时候。C代码编译成可执行文件的时候，指令没有被CPU执行，这个时候算是编译时，就是编译的时候。 参考： glibc, glib and gnulib c runtime libray 是什么 什么是 runtime library 运行时（runtime）是什么意思？应该怎样深入且直观地理解？","link":"/o/2019/11/29/Linux-version/"},{"title":"Node 中的一些核心 API","text":"背景一直以来有从 Web 开发领域切入到 Server 开发领域的打算， 作为一名前端开发人员最熟悉的 Server 端技术那肯定就数 JS 啦。所以自然而然的就会想到 Node。 长期以来在业务中只是使用 Node 作为构建工具（webpack）。今年好了很多，在自己负责的业务中使用 Node 去 server 一个站点，搭建了业务中简单的 BFF 层、在自己的业余开发中也能去写一一些简单的 Node 服务，按图索骥的仿照着公司基础架构部门写的一些 Node 服务进行练习。 我认为的学会并不只是搭建一些基本的功能服务那么简单，所以还是觉得陌生。我想一来来是因为在自己日常的业务开发中使用频次还是过少熟练度上不去，二来自己缺乏服务端开发（操作系统：文件系统、线程、进程）的相关知识（eg Event-Loop 下半年在和 SRE 合作后觉得有了一定的提升）导致看不懂 Node 的文档，每一个单词都明白但还是缺乏一种熟悉感。 在今天看到梨 uglee 写的 tesla.js 后产生了那么一丢丢感觉，又看了美团技术团队关于 stream 的介绍后有种鼻塞忽然通了的感觉。我打算把这些文章记录下来。 文章全面了解 Stream - Stream handlebook Node.js Stream 基础篇","link":"/o/2019/11/19/Node/"},{"title":"OA hisTORY","text":"banana 中项目名称 类型 访问地址 用途 quard static server + 静态资源 https://oa.gotokeep.com/newoa https://oa.gotokeep.com/pc 所有 oa 项目的静态服务器 + oa后台的页面 newoa 静态资源 https://oa.gotokeep.com/newoa 迁移后的 oa oa-mobile 静态资源 https://oa.gotokeep.com/oa-mobile 企业微信提单","link":"/o/2019/10/11/OA/"},{"title":"SICP-1","text":"Lisp 语言具有的特性之一计算过程的 Lisp 描述 （又称为过程） 本身又可以作为 Lisp 的数据来表示和操作。 程序设计语言的基本元素 基本表达形式， 用于表示语言所关心的最简单个体 组合的方法，通过它们可以从比较简单的东西发出 抽象的方法 复合过程 表达式Lisp 中使用的是前缀表达书 命名和环境变量：通过名字去使用变量的方式 1( define size 2 ) 环境：我们一般将值与符号进行关联，然后再去使用这个变量。这就意味着解释器必须维护某种存储的能力，以便保持有关名字的 「名字-值」的对偶的轨迹，这种存储叫做环境。在一个计算过程中会包许多个不同的环境。 复合过程 数和算术运算是基本的数据和过程 组合式的嵌套提供了一种组织多个操作的方法 定义是一种受限的抽象手段，它为名字相应的值 1234( define square (x) (* x x)) 应用序和正则序 正则序：完全展开后而归约。应用序列： 解释器中的，先求值参数而后应用的方式。 条件表达式和谓词( define (abs x) (cond ((x &gt; 0) x) ((x = 0) 0) ((x &lt; -) (-x)) )) 练习练习 1.21234(/ (+ 5 4 (- 2 ( - 3 ( + 6 (/ 4 5) )))) (* 3 (- 6 2) (- 2 7))) 练习 1.312345678( define (max a b) ( cond ((a &gt; b) a) ((a = b) a) ((a &lt; b) b) )) 练习 1.5牛顿法求平方根练习 1.6练习 1.7练习 1.8scheme \b使用前缀表达式来写 When $a \\ne 0$, there are two solutions to \\(ax^2 + bx + c = 0\\) and they are$$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$$ 使用 scheme 写一个递归 1234567(define (fact n) (if (= n 1) 1 (* n (fact (- n 1))) ))(fact 3) scheme 中的 cond123456(define (testCond x) (cond ((&lt;= x 0) (- 0 x)) ((&gt; x 1) x) )) scheme 中定义函数的两种形式 第一种 12345678(define Hello ( lambda (a b c) (+ a b c) ))(Hello 1 2 3) 第二种 12345( define ( Hello a b c) (+ a b c)) 参考 如何理解计算机中的谓词 Predicate \b因为比较懒所以没有在本地搭建开发环境,直接使用的是 repl.it 这样一个 web scheme enviroment \b","link":"/o/2020/01/01/SICP-1/"},{"title":"使用 JavaScript 进行二进制计算","text":"reduecRight 的 Polyfill 1var t = Object(this), len = t.length &gt;&gt;&gt; 0, k = len - 1, value;","link":"/o/2019/12/11/binary/"},{"title":"浏览器概览","text":"浏览器的组成结构 用户界面 包括地址栏、前进、后退、书签栏。 浏览器引擎 在用户界面和浏览器引擎之间传送指令。 呈现引擎 负责呈现浏览器内容，负责解析 HTML 和 CSS 内容，并将解析后的内容现实在屏幕上。 网络 用于网络调用。 用户界面后台 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。 JavaScript 解释器 解析执行 JavaScript 代码。 数据存储 持久层，浏览器需要在硬盘上保存各种数据，例如 Cookie，新的 HTML 5 规范定义了网络数据库，这是一个完整轻便的网络数据库 和大多浏览器不同，Chrome 的每个标签页分别对应一个呈现引擎实例，每个标签页都是一个独立的进程。 呈现引擎呈现引擎，又称为渲染引擎也成为浏览器内核，在这方面又称为 UI 线程，这是由各大浏览器厂商根据 W3C 标准自行研发的， 常见的内核有四种 （Webkit (chrome, safari) Gecko(firefox)）。 呈现主流程呈现引擎最大的作用是用于呈现，也就是在浏览器中显示请求的内容。一开始从网络层获取文档内容，内容大小限制一般在 8000 个块以内, 然后进行以下流程： 使用 HTML 构建 DOM 结构，并将各个标记转换为 “内容树” 上的 DOM 节点。同时也会解析外部 CSS 文件以及样式文件中的样式数据。 HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构： 呈现树。 呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。 呈现树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。 示例：webkit 主流程示例图 示例：Mozila 的 Gecko 呈现主流程引擎 JavaScript 解释器什么是 JavaScript 解释器？简单地说，JavaScript 解释器就是能够“读懂” JavaScript 代码，并准确地给出代码运行结果的一段程序。 所以 JavaScript 解释器，又称为 JavaScript 解析引擎，又称为 JavaScript 引擎，也可以成为 JavaScript 内核，在线程方面又称为 JavaScript 引擎线程。比较有名的有 Chrome 的 V8 引擎（用 C/C++ 编写），除此外还有 IE9 的 Chakra、Firefox 的 TraceMonkey。它是基于事件驱动单线程执行的，JavaScript 引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个 JavaScript 线程在运行 JavaScript 程序。 学过编译原理的人都知道，对于静态语言来说（如Java、C++、C），处理上述这些事情的叫编译器（Compiler），相应地对于 JavaScript 这样的动态语言则叫解释器（Interpreter）。这两者的区别用一句话来概括就是：编译器是将源代码编译为另外一种代码（比如机器码，或者字节码），而解释器是直接解析并将代码运行结果输出。 比方说，firebug 的 console 就是一个 JavaScript 解释器。但我们无需过多在这些点上纠结。因为比如像 V8，它其实是为了提高 JavaScript 的运行性能，会在运行之前将 JavaScript 编译为本地的机器码然后再去执行，这样速度就快很多，相信大家对 JIT（Just In Time Compilation）一定不陌生吧。 JavaScript 解释器和我们平时讨论的 ECMAScript 有很大关系，标准的 JavaScript 解释器会根据 ECMAScript 标准去实现文档中对语言规定的方方面面，但由于这不是一个强制措施，所以也有不按照标准来实现的解释器，比如 IE6，这也是一直困扰前端开发的一个来由——兼容问题。有关 JavaScript 解释器的部分不做过于深入的介绍，但是由于我们对它有了部分的了解，接下来可以介绍一个新的部分——线程。 JavaScript 与浏览器的线程机制作为浏览器脚本语言，JavaScript 主要用于处理页面中用户交互，以及操作 DOM 树、CSS 样式树（当然也包括服务器逻辑的交互处理）。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征。 我们可以回顾一下最开始所提的一个问题：Web Worker 真的让 JavaScript 拥有了多线程的能力吗？ 为了利用多核 CPU 的计算能力，在 HTML5 中引入的工作线程使得浏览器端的 JavaScript 引擎可以并发地执行 JavaScript 代码，从而实现了对浏览器端多线程编程的良好支持。Web Worker 允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM 。所以，这个新标准并没有改变 JavaScript 单线程的本质。 为什么页面会卡顿？由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。为了防止渲染出现不可预期的结果，浏览器设置 UI 渲染线程与 JavaScript 引擎线程为互斥的关系，当 JavaScript 引擎线程执行时 UI 渲染线程会被挂起，UI 更新会被保存在一个队列中等到 JavaScript 引擎线程空闲时立即被执行。 于是，我们便明白了：假设一个 JavaScript 代码执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染出现“加载阻塞”的现象。当然，针对 DOM 的大量操作也会造成页面出现卡顿现象，毕竟我们经常说：DOM 天生就很慢。 所以，当你需要考虑性能优化时就可以从如上的原因出发，大致有以下几个努力的方面： 减少 JavaScript 加载对 DOM 渲染的影响（将 JavaScript 代码的加载逻辑放在 HTML 文件的尾部，减少对渲染引擎呈现工作的影响）； 避免重排，减少重绘（避免白屏，或者交互过程中的卡顿）； 减少 DOM 的层级（可以减少渲染引擎工作过程中的计算量）； 使用 requestAnimationFrame 来实现视觉变化（一般来说我们会使用 setTimeout 或 setInterval 来执行动画之类的视觉变化，但这种做法的问题是，回调将在帧中的某个时点运行，可能刚好在末尾，而这可能经常会使我们丢失帧，导致卡顿）； 优化方面可以看 优化 JavaScript 的执行 浏览器中的那些线程事实上我们在使用浏览器的时候都会涉及到网络工具、浏览器事件、定时器触发线程。事实上这些线程如果出现在主线程上的话工作效率会非常的低下（这里的工作效率指的是人能看到的渲染引擎渲染出的页面）所以浏览器为这些功能独立设计了其他的线程 浏览器事件触发线程：当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等，但由于 JavaScript 的单线程关系所有这些事件都得排队等待 JavaScript 引擎处理 定时器触发线程：浏览器定时计数器并不是由 JavaScript 引擎计数的, 因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案 异步 HTTP 请求线程：在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理； 总结这篇大部分基本摘抄 聊聊 JavaScript 与浏览器的那些事 - 引擎与线程和 浏览器的工作原理：新式网络浏览器幕后揭秘主要是自己对浏览器结构的一个简单梳理、也是为下一篇 Event Loop 的铺垫。 引用： 聊聊 JavaScript 与浏览器的那些事 - 引擎与线程 JavaScript 运行机制详解：再谈Event Loop 浏览器的工作原理：新式网络浏览器幕后揭秘","link":"/o/2019/11/28/browser/"},{"title":"click-jacking","text":"什么是 Click Jacking本质上是 UI 覆盖攻击的一种， 12341. Flash 点击劫持2. 图片覆盖攻击(XSIO)3. 拖拽劫持，主要用于数据窃取4. 触屏劫持(TapJacking) 手段 iframe 覆盖，覆盖层 opacity 调为0 图片覆盖 解决方法使用一个 Http Header X-Frame-Options。 它有三个可选值。 DENY：浏览器会拒绝当前页面加载任何frame页面； SAMEORIGIN：frame页面的地址只能为同源域名下的页面； ALLOW-FROM origin：允许frame加载的页面地址","link":"/o/2020/01/20/click-jacking/"},{"title":"假如我来负责一家公司的前端体系","text":"很长一段时间都在和 SRE、Infra 合作主要做的是一些比较基础的服务。 这篇文章主要记录工作中做过的和自己见过的重要的东西，想象如果自己有一天到了一家没有技术的公司自己都得做什么。 私服在一个公司的前端开发中，理想情况是不同项目应当都使用公司提供的脚手架，并且由 infra 做统一维护。但是做过开发的人都知道，做开发时不会每个组件都自己写，我们通常会引用一些外部文件（JavaScript -&gt; node_modules, Java -&gt; Maven）。这个时候我们希望能把公司开发者使用的组件、包都放在自己的服务器上，因为主要有以下几点好处： 节省自己的外网带宽 加速Maven、npm的构建，提升构建速度。 部署自己的第三方组件（公司的公共 node、 开发框架） node_modules 依赖 使用工具： Nexus Repository Manager OSS 3.x 构建平台计划：主要包含 CI CD, 关于 jenkins 进行自动化共建的内容 通用脚手架计划： web pc H5 小程序 快应用 chrome extension 通用 CLI 工具 作为通用脚手架的承载 文档体系主要用于知识分享 docsify vuepress 日志收集对线上页面进行日志收集以便快速定位问题 性能监控对线上问题进行性能监控","link":"/o/2019/11/27/fe-leader/"},{"title":"如何去撤销一个已提交的 commit 节点","text":"撤销某一个具体的节点12git revert a7d8dcaa4e25667c9aaaf2a0809aca7fe1a27b6d 但是当这个节点是一个 mer\bge 节点的时候， 你根本无法去 revert 这个节点，因为你不知道 merge 的哪一条分支应该作为主线，哪个分支作为他\b撤销后的主分支，因此git 会输出\b错误信息: 1error: commit cae5381823aad7c285d017e5cf7e8bc4b7b12240 is a merge but no -m option was given. 让我们来看看这个 m \b参数代表什么 Usually you cannot revert a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent. Reverting a merge commit declares that you will never want the tree changes brought in by the merge. As a result, later merges will only bring in tree changes introduced by commits that are not ancestors of the previously reverted merge. This may or may not be what you want 翻译过来就是 通常情况下，你无法 revert 一个 merge，因为你不知道 merge 的哪一条线应该被视为主线。这个选项（-m）指定了主线的 parent 的代号（从1开始），并允许以相对于指定的 parent 的进行 revert。 revert 一个 merge commit 意味着你将完全不想要来自 merge commit 带来的 tree change。 因此，之后的 merge 只会引入那些不是之前被 revert 的那个 merge 的祖先引入的 tree change，这可能是也可能不是你想要的。 \b如同下图所示，revert 到 ‘thumbup-feature’ 的时候不知道 到底是 revert 到绿色的线还是紫色的线。 也可以使用 git show 命令查看相关信息 123456789git show\b输出内容：commit cae5381823aad7c285d017e5cf7e8bc4b7b12240Merge: edf99ca 125cfddDate: Thu Apr 12 18:27:21 2018 +0800 Merge tag &apos;thumbup-feature&apos;如\b下图标示的 parent1 \b对应 执行 git revert cae5381 -m 112345678910111213git revert cae5381 -m 1输出：Revert &quot;Merge tag &apos;thumbup-feature&apos;&quot;This reverts commit cae5381823aad7c285d017e5cf7e8bc4b7b12240, reversingchanges made to edf99ca31755a27b0a43b290263ed810833a95c4.[master f0aac26] Revert &quot;Merge tag &apos;thumbup-feature&apos;&quot; 2 files changed, 2 deletions(-) delete mode 100644 file3 delete mode 100644 file4 复制代码file3 和 file4 是 feature branch 上的 commit 引入的文件，被正确地删掉了 执行 git revert cae5381 -m 2123456789git reset --hard d208cba git revert cae5381 -m 2输出[master 2c5a0ee] Revert &quot;Merge tag &apos;thumbup-feature&apos;&quot; 2 files changed, 2 deletions(-) delete mode 100644 file5 delete mode 100644 file6 这种 revert 把 master 在 feature branch 期间进行的 commit 都给干掉了。 本文绝大部分的内容和数据都引用自 ULIVZ 的文章: 当你决定去 revert 一个merge commit","link":"/o/2019/12/11/git-revert/"},{"title":"HTTP 请求走私","text":"参考： 知道创宇：HTTP 走私","link":"/o/2019/12/10/http-smuggling/"},{"title":"javascript-extends","text":"","link":"/o/2019/12/26/javascript-extends/"},{"title":"实现 JavaScript 中的 new 关键字","text":"众所周知 JavaScript 是一门基于原型、函数先行的多范式语言，它已经由ECMA（欧洲电脑制造商协会）通过ECMAScript实现语言的标准化。 想要知道如何实现 new 关键字我们就得搞清楚 new 做了什么。 JavaScript 中的 new 做了什么 ?按照 spec ,new 依次做了以下 4 \b件事情： 创建一个对象 new Object 链接该对象（即设置该对象的构造函数）到另一个对象 ； \b将步骤 1 \b新\b创建的对象作为 this 的上下文； 如果构造函数没有返回对象\b则返回 this 最终实现代码 123456function objFactory() &#123; var Constructor = [].shift.call(arguments) var obj = Object.create(Constructor.prototype) var ret = Constructor.apply(obj, arguments) return (typeof ret instanceof Object || ret === null) ? ret : obj&#125;","link":"/o/2019/12/28/javascript-new/"},{"title":"使用css selector 记录用户输入信息","text":"CSS3 Selector 实现使用 CSS 记录用户信息主要使用了 CSS3 中的 selector。 序号 选择器 含义 1 E[attr^=”val”] 属性 attr 的值以 “val” 开头的元素 2 E[att$=”val”] 属性 attr 的值以 “val” 结尾的元素 3 E[att*=”val”] 属性 attr 的值以 “val” 字符串的元素 键位匹配浏览器自身默认不会将用户输入的值同步到 value 中, 但像一些框架会将用户输入值同步到 value 中。Demo Link 将值同步到 value 之后，我们可以使用 css 来做匹配，对应的键位发送到不同的链接。 12345678/* 命中 0 时 请求对应的接口 */input[type=\"password\"][value$=\"0\"] &#123; background-image: url(\"http://localhost:3000/0\"); &#125;/* 命中 1 时 请求对应的接口 */input[type=\"password\"][value$=\"1\"] &#123; background-image: url(\"http://localhost:3000/1\"); &#125; 防御措施在知道可以使用 css 来记录按键之后我兴冲冲的找到对应的 github demo，按照文档所说打开 https://instagram.com，安装 Chrome Extension、输入密码但却然而却发现并没有记录到信息，出现了如下的错误信息： 在 antd-design-pro 示例登录页倒是可以。 这是因为 https://instagram.com 使用了 CSP (Content Security Policy)。 说白了就是为了页面安全而制定的一系列防护措施，通过CSP所约束的规则制定可信的内容来源（脚本、图片、iframe、fton、style 等可能的远程资源）。 引用CSS KeyloggerContent Security Policy (CSP) 是什么？为什么它能抵御 XSS 攻击","link":"/o/2019/12/13/keylogger/"},{"title":"计划表","text":"组件文档的选型 markdown-it 将 vue 组件插入到文档中 story book 实时交互式 关于 sha 那個長得很像亂碼 SHA-1 是怎麼算出來的？ 哈希算法与MD5、SHA virtual dom 那個長得很像亂碼 SHA-1 是怎麼算出來的？ 哈希算法与MD5、SHA leetcode","link":"/o/2020/01/14/plan/"},{"title":"Promise 碎片 （等待整理）","text":"我所做的一切，不过是在取悦一个影子 什么是 Promise ? 定义：Promise \b\b是一个对象，他会在未来的某个时刻生成\b一个值，已完成 （resolved）的值或者一个没有完成的理由。 特性：Promise 存在三个状态 FULLFILLED （已完成）、REJECTED （已拒绝）、PENDING （等待中） 回调：Promise 的使用者可以附上回调函数来处理已完成的值或者拒绝的原因 Promise 是热切的，一旦 promise 的构造函数被调用，它就会开始执行你交给它的任务。如果你需要一个懒惰的，请看 observables 或者 task。 Promise 用法123456789101112131415const promise = new Promise(function(resolve, reject) &#123; // Your code if (/* 异步操作成功 */) &#123; resolve(value) &#125; else &#123; reject(value) &#125;&#125;)promise.then(function(value) &#123; // success&#125;, function (error) &#123; // error&#125;) Promise APIPromise 规范有很多，Promise A、 Promise B、 Promise A+、Promise D 目前 ES6 的 Promise 是基于 Promise A+ \b实现的 我们知道 Promise 是一个构造函数，需要用 new 调用，并有以下几个 api：( 从哪里知道？ 怎么知道？) API: 12345678910function Promise(resolver) &#123;&#125;Promise.prototype.then = function(onResolved) &#123;&#125;Promise.prototype.catch = function(onRejected) &#123;&#125;Promise.resolve = function() &#123;&#125;Promise.reject = function() &#123;&#125;Promise.race = function() &#123;&#125;Promise.all = function() &#123;&#125; 同步任务（存放在执行栈） 异步任务 （存放在异步队列） 异步任务又分为宏任务和微任务 Chrome: 宏任务 Task: setTimeout setInterval setImmediate(IE专用) messageChannel 等待执行栈和微任务队列都执行完毕才会执行，并且在执行完每一个宏任务之后，会去看看微任务队列有没有新添加的任务，如果有，会先将微任务队列中的任务清空，才会继续执行下一个宏任务 微任务 microTask：promise MutationObserver… 当执行栈中的代码执行完毕，会在执行宏任务队列之前先看看微任务队列中有没有任务，如果有会先将微任务队列中的任务清空才会去执行宏任务队列 Node: 宏任务 Task: setTimeout setInterval… 微任务 microTask: process.nextTric promise setImmediate 12345678910111213141516171819var isFulfilled = false;var d = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve(2); isFulfilled = true; &#125;, 50);&#125;);d.then(function onFulfilled() &#123; console.log(isFulfilled == true)&#125;); Promise 的零碎实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177const PENDING = \"PENDING\"const RESOLVED = \"RESOLVED\"const REJECTED = \"REJECTED\"// 值穿透// 构造函数class MyPromise &#123; constructor(exexutor) &#123; this.status = PENDING this.value = undefined // 回调函数 this.onResolvedCallback = [] this.onRejectedCallback = [] // inner resolve let _resolved = (value) =&gt; &#123; /** * 这里增加 setTimeout 是为了避免这种情况的出现 * promise2 = new MyPromise(function(resolve, reject) &#123; * promise2().then(() =&gt; &#123; * console.log(1111) * &#125;) * &#125;) * */ setTimeout(() =&gt; &#123; if (this.status === PENDING) &#123; this.status = RESOLVED this.value = value // 针对非链式调用 /** * P = new Promise() * * P.then() * * P.then() */ this.onResolvedCallback.forEach(cb =&gt; cb(value)) &#125; &#125;) &#125; // inner reject let _rejected = (reason) =&gt; &#123; if (this.status === PENDING) &#123; this.status = REJECTED this.value = reason // 针对非链式调用 this.onRejectedCallback.forEach(cb =&gt; cb(reason)) &#125; &#125; try &#123; exexutor(_resolved, _rejected) &#125; catch (err) &#123; _rejected(err) &#125; &#125; // 原型链表 then(onResolved, onRejected) &#123; let promise2 let self = this // 根据标准规定, 如果 then 的参数不是一个函数那么, 就抛出 onResolved = typeof onResolved === 'function' ? onResolved : function (value) &#123; return value &#125; onRejected = typeof onRejected === 'function' ? onRejected : function (reason) &#123; return reason &#125; if (this.status === PENDING) &#123; // 如果当前的Promise还处于pending状态，我们并不能确定调用onResolved还是onRejected， // 只能等到Promise的状态确定后，才能确实如何处理。 // 所以我们需要把我们的**两种情况**的处理逻辑做为callback放入promise1(此处即this/self)的回调数组里 // 逻辑本身跟第一个if块内的几乎一致，此处不做过多解释 return promise2 = new MyPromise(function (resolve, reject) &#123; self.onResolvedCallback.push(function (value) &#123; try &#123; var x = onResolved(self.value) if (x instanceof MyPromise) &#123; x.then(resolve, reject) &#125; resolve(x) &#125; catch (e) &#123; reject(e) &#125; &#125;) self.onRejectedCallback.push(function (reason) &#123; try &#123; var x = onRejected(self.value) if (x instanceof Promise) &#123; x.then(resolve, reject) &#125; &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125;) &#125; if (this.status === RESOLVED) &#123; return promise2 = new MyPromise(function (resolve, rejected) &#123; try &#123; x = onResolved(self.value) if (x instanceof MyPromise) &#123; // 如果onResolved的返回值是一个Promise对象，直接取它的结果做为promise2的结果 x.then(resolve, rejected) &#125; resolve(x) // 否则，以它的返回值做为promise2的结果 &#125; catch (err) &#123; rejected(err) &#125; &#125;) &#125; if (this.status === REJECTED) &#123; return promise2 = new MyPromise(function (resolve, rejected) &#123; try &#123; x = onRejected(self.value) if (x instanceof MyPromise) &#123; // 如果onResolved的返回值是一个Promise对象，直接取它的结果做为promise2的结果 x.then(resolve, rejected) &#125; &#125; catch (err) &#123; rejected(err) &#125; &#125;) &#125; &#125;&#125;// then 方法var isFulfilled = false;var d = new MyPromise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve(2); isFulfilled = true; &#125;, 50);&#125;);d.then(function onFulfilled() &#123; console.log(isFulfilled == true)&#125;);// 测试let promise = new MyPromise(function (resolve, rejected) &#123; setTimeout(() =&gt; &#123; console.log('pending') resolve() &#125;, 1000);&#125;).then(() =&gt; &#123; console.log(2)&#125;)let promise2 = new Promise(function (resolve, rejected) &#123; setTimeout(() =&gt; &#123; console.log('pending') resolve() &#125;, 1000);&#125;).then(() =&gt; &#123; console.log(2)&#125;) 参考 从零一步一步实现一个完整版的Promise https://juejin.im/post/5aa7868b6fb9a028dd4de672 Promise A+ 规范 史上最易读懂的 Promise/A+ 完全实现 剖析Promise内部结构，一步一步实现一个完整的、能通过所有Test case的Promise类 后续 从如何停掉 promise 链说起 拓展 国内绝大部分 Task MicroTask 的来源 评论区：Monad的Data.task 实现Promise","link":"/o/2019/12/06/promise/"},{"title":"埃鲁德·基普乔格：成为传奇","text":"天赋异禀者通常有机会得到冠军，同时兼具天赋、自律又懂得思考的人则最终会成为传奇。 2012年开夏，肯尼亚国家队的奥运选拨赛，埃鲁德·基普乔格5000米和万米都位列第7。连续第三次参加奥运的愿望落空了。 那年他27岁。 彻底无缘伦敦后，基普乔格很快做了个决定，转项更长距离的路跑。也就是马拉松。 职业运动员的27岁，一小撮人准备好了大张旗鼓的收获，绝大多数人却要逐渐开始面对压力和焦虑的双重危机。这个年纪，潜力渐行渐远，兑现不出亮眼的成绩，留给职业生涯下半场的时间越来越少。 截止那时，基普乔格最能拿出手的荣誉： 03年世锦赛冠军； 04年雅典奥运铜牌； 08年北京奥运会银牌； 他主项5000米，兼跑越野和10000米。放眼东非，特别肯尼亚和埃塞俄比亚，长跑就是“国粹级”运动，如同乒乓球之于中国一样。非长跑强国的职业运动员，丢到肯尼亚未必能稳赢当地高中生。 除了奥运会和世锦赛，在当地，其它低级别赛事的冠军多如牛毛。当地人提到长跑言必称冠军。能阻碍他们的，一个是激烈的内部竞争，另一个对他们来说，出去跑比赛依然不是件容易的事。 27岁时的基普乔格算得上是位好好先生，低调谦逊，不缺努力。他的职业生涯开头很耀眼，17岁打破世界青少年纪录，而后拿下世锦赛冠军，惊为天人。首都内罗毕很快以他名字命名了一条街道，来纪念天才少年的诞生。 此后十年间，基普乔格的表现不能算不出色，但距离曾经的期望值似乎还差点意思。所有年少成名者，身上都有类似的困扰 名义上，别人视你为乔丹的接班人，事实却是，如果无法达到科比的成就，你的职业生涯都很难被认为是成功的。 又好比，论实力，基普乔格已经达到布洛阿特峰、希夏邦马峰之类的高度，但绝大多数人提起世界最高峰，只说得出珠穆朗玛。知道乔戈里峰的都寥寥。 2. 职业的马拉松选手大多分两类，一类早早就确定以马拉松为主项，平时偶尔跑个5000/万米比赛；另一类则出身更短距离的中长跑。生涯末年油箱还是满的，加速却慢慢变的吃力，所以就打个方向，把赛场从跑道转向公路。 基普乔格之前，马拉松的“GOAT（Greatest of all time）”，海尔·格布雷西拉西耶，就是后一类的代表。 「长跑之王」格布雷西拉西耶有着完美的职业生涯。事后看，贝克勒继承了他中长跑的衣钵，基普乔格则无缝衔接马拉松最强者名号。 和绝大多数人一样， 基普乔格首次亮相的是半程马拉松。2012年9月，他延续了自己惊艳亮相的传统，在里尔半马以季军完赛。59分25秒的成绩也是有史以来首次跑半马第二快的。不到一个月后的世界半马锦标赛，基普乔格又以第六名完赛。 3个月后，在巴萨罗那跑完第三个半程，基普乔格的“热身”正式结束，即将迎来自己的首个全程马拉松。 基普乔格的教练是帕特里克·桑，在“选择哪场比赛作为首马”时，两人看法不同。基普乔格收到伦敦马拉松组委会的邀约，更想跑伦敦。桑却倾向去德国汉堡，即便远不如前者的名头响亮。 桑是基普乔格的第一任教练，也是迄今唯一一位。他年轻时也是运动员，92年巴塞罗那奥运会拿到过银牌。相比运动生涯，他最大成就是慧眼识才，当了教练带出过杰弗里·卡姆沃罗、斯蒂芬·基普罗蒂奇（伦敦奥运会冠军）这些顶尖高手。 帕特里克·桑和基普乔格住的不远。桑拿到奥运会银牌给基普乔格很大激励发，他给桑写了封信，询问是否可以为自己做一份训练计划。而后两人几次交流，便成为师徒，一晃二十年。 基普乔格出身单亲家庭，父亲只是照片里的模糊剪影。十几岁跟了桑后，多少也在他身上寄托了类似父亲的情感。两人相差20岁，亦师亦友。 桑并不是那种严苛的管理者，也从不觉得天赋能决定一切。他认为，“心理素质要比身体素质更重要。（肯尼亚）从不缺才华横溢的苗子，只有心理强大的人才会走的很远。”想必当年相中基普乔格，桑在他身上发现了些其它孩子没有的特质。 桑见证过基普乔格年轻时候一飞冲天，也明白长期被其他人压制是什么滋味。基普乔格换项的选择，帕特里克·桑显然也很支持。对于首马，师徒两人关在房间聊了整整两个小时。“马拉松是个新的领域，你得学习更多东西。”这些是桑摆在明面的话。实际上，桑希望基普乔格能以旗开得胜的姿态开始马拉松。 去汉堡成为冠军，和去伦敦拿个名次，两者在心气上完全没法比。用冠军开路，未来就会不一样。 事实证明桑的确眼光独到，基普乔格也不负期望。 在汉堡平坦的公路上，距离终点剩下不到十公里，基普乔格从第一集团突围，越跑越快，2小时05分30秒第一个完赛，并且还打破了赛会纪录。冲线后的基普乔格表现出少有的激动，“我为自己感到骄傲，我喜欢马拉松。” “没想到我能跑这么快。” 如果存在另一个平行世界，另一个「基普乔格」会在同一年的伦敦拿到还不错的名次，庆幸换项的抉择并不赖，而后满世界参赛，在职业生涯后期成为一个小有名气的马拉松选手。 好在假设并没有发生。 3. 至此，基普乔格28岁，身上多了「马拉松冠军」这个标签。 “冠军”与“热门选手”的区别，类似“斗战胜佛”与“齐天大圣”。让孙悟空脱胎换骨的并不是去西天路上他又学会多少技能点，而是前后的心境截然不同了。 这听起来有些唯心主义。不过对基普乔格来说，他的生活训练一直规律且认真，很难要求更多一些。他太需要一个冠军证明了。 汉堡过去5个月后，基普乔格第一次跑柏林马拉松。柏林是一个见证奇迹的地方。诞生过11个世界纪录，世界最好的TOP15成绩，有9个在这里。最近16年，马拉松能不能破纪录，都是柏林说了算。 尽管基普桑最终夺冠，也不负众望刷新了世界纪录，人们对亚军基普乔格的期望甚至更高一些。第二场马拉松便实现204，比起新科世界纪录也只慢了42秒。有人开玩笑，难不成基普乔格用了十年时间攒潜力，就是拗劲准备在马拉松大器晚成？ 再往后，2014年春季，以速度闻名的鹿特丹马拉松，基普乔格拿到第二个冠军。30岁前夕，又在芝加哥拿下个人第一个WMM（世界马拉松大满贯）的冠军。 跑马拉松的前两年，看得出基普乔格每一步选择堪比教科书，相当的工整。他在比赛频次上非常克制，每年只跑春秋两场比赛，每一次出场背后都意味着完成了一整套的训练计划。赛前采访，别人会说，我期望跑个什么成绩。基普乔格则表示，我的身体状况很好，也没有什么心理压力。 开头两年收获3个冠军，唯一一次没夺冠还是同胞表现逆天破了纪录。成绩另说，光是能沉住气少参赛保训练这点，基普乔格就比很多东非选手难得了。 东非盛产长跑好手，尤其高原上的肯尼亚和埃塞俄比亚。贫瘠了数百年加上生活动荡，当地人想改变生活的选择并不多，长跑已经是一个半产业化的途径。这催生出一群到处比赛赢取奖金的“赏金跑者”。 东非的跑步者村落也有不成文的规定，冠军意味着全村人脸上有光，也顺带经济方面得到恩泽改善下生活。 除了金字塔顶端的高手，绝大多数职业长跑运动员都要背负养家糊口的压力。比赛机会对他们而言非常珍贵，签约经纪团队后都会尽可能多的想要参赛。 马拉松吃的毕竟是身体饭，比赛多了，训练难免缺少系统性，名次和成绩向来又很难两全。这也是东非长跑军团过去的一个现象，万神殿里冠军排排坐，却很难选出个公认的带头大哥。 4. 基普乔格和桑能长久合作，训练上的合拍是一方面，在参赛频次方面也几乎没有意见相左过。这点难能可贵。 桑当年在一堆肉眼可见的天赋里相中基普乔格，很重要的原因是，“这孩子表现出很强的求知欲。”基普乔格总喜欢去研究分析跑步更深一层的东西，这种求知也让他变得非常善于思考，同时兼具独立冷静的特质。 即便有过低谷，桑依然认为基普乔格是那种可以达到某些成就的人。 冷静爱思考，训练营的人叫基普乔格“哲学家”；所参加赛事金牌必达，跑步圈内私下叫他“冠军收割机”。2015年，基普乔格终于完成自己第一个伦敦马拉松。这里后来成为他的福地，接下来又两次折桂。同年秋天基普乔格再次选择跑柏林马拉松，并如愿夺冠。 回顾过程，不夸张的讲，在当时那样的情况下还能淡定完赛的，可能也只有基普乔格了。 比赛开始不久他发现自己的鞋垫松动了。而后每一步奔跑，鞋垫就一点点慢慢滑出。后面的整整16公里，两只鞋垫肆无忌惮的抽打脚踝，双脚在鞋子显然也好受不到哪去。桑也跟着紧张了全程。桑不怕基普乔格退赛，他只担心基普乔格会受伤。 然后就这样穿着不合脚的鞋，基普乔格竟然出人意料的跑出自己的PB（个人最好成绩）2小时04分整！当天各大媒体头条照片里，脚下荧光色飞舞的鞋垫很抢镜，基普乔格则淡定的保持着微笑飞奔。 过程跌宕，结局欢喜。 基普乔格证明了自己的专注和冷静足以应对42公里可能出现的任何问题。桑开始意识到，在马拉松这个距离，基普乔格是他所见过最具精神力量的选手——未来或许不是再多拿几个冠军的事了。 媒体们事后细思极恐——换成别人，半遛着鞋垫早该退赛了，基普乔格却差点跑进204。真是神人。 媒体们夸起来都很没节操。有人说，基普乔格是博尔特的「远程版本」。但有人马上反驳，博尔特有他一半自律？ 也是从2015年开始，按照WMM（世界马拉松大满贯）的算法，基普乔格拿到最高积分，成为公认的世界马拉松第一人。再往后连续蝉联至今，前无古人。 2016年伦敦马拉松，基普乔格又拿下冠军还有新的赛会纪录，比当时的世界纪录只慢了8秒。双喜临门，已经31岁的他收到确认，将再次代表肯尼亚参加奥运会。 四年前恐怕没有人会想到故事是这样发展的。 27岁转项马拉松后，基普乔格把自己每一次的训练都记在笔记本上，直到今年柏林破纪录，他记满了整整15本。他的训练计划没有与众不同的地方。每个训练日，他用80-90%的能量把计划完成，然后比赛日，用100%的能量输出。 没有伤病，没有压力，身体状态很好。确认了这三点，冠军就是探囊取物。 里约奥运会马拉松成了基普乔格的个人秀。前半程他还收着跑，后半程眼看夺金没什么压力，于是才放开了发力。赛后数据，后半程比前半程快了整整3分钟。 基普乔格以领先第二名多达70秒的优势收获金牌。这也是自1972年以来奥运会马拉松冠亚军的最大差距。 现代奥运会举办以来的不成文传统，马拉松被安排在奥运会的最后一天举行。比赛最后在体育场结束，意在向奥运精神致敬、向这座城市致敬。 四年又四年，基普乔格被视为夺冠热门，也曾看着贝克勒们绝城而去，而自己的国家队大门徐徐关上。在快32岁的时候王者归来，他只是说，每次训练和比赛我都很高兴，“跑步是我的生命。” 5. 2017年，基普乔格正规的马拉松赛只有下半年的柏林，上半年重头戏是Nike的Breaking 2“破二挑战”。Nike组了基普乔格等三人，在意大利蒙扎赛道尝试人类是否能在2小时内跑完42.195公里。 很少有人知道“破二”前，基普乔格和这个挑战的策划团队面对了很大压力。社交媒体上不看好的声音山呼海啸，绝大多数评论认为，人类并不具备挑战成功的可能。即便你是基普乔格。 甚至于，身为教练的桑在挑战开始前几天表现的都非常紧张，设想过很多可能出现的状况。反倒基普乔格则异常的淡定。他充满信心，又不会多说任何一句大话。 塔德塞和德西萨过早的落后既定配速并未给基普乔格太大影响。最终的最终，他只比2小时超出了25秒。 兴许这是最累的一次42.195公里，基普乔格确实拼劲了全力。仔细看直播画面，最后几公里不经意已然流露出咬牙力撑的表情，但加速冲线时，他依然保持着微笑。这是基普乔格的招牌表情，他习惯用轻描淡写的方式去给力求结果的证明者一个答案。 关于破二的结果，基普乔格至始至终没流露出过任何遗憾。他觉得“遗憾是缺乏自律的表现”。以及，“人类的目标并不存在什么极限。”基普乔格后来自己说了个细节，跑完瞬间他忍不住流泪了。正巧当时开始下雨，泪水就得以顺其自然的藏匿起来。 离开蒙扎后，基普乔格回到酒店，独自到旁边公园又慢跑了很久。只属于他一个人的闲暇时刻。 6. 纽约时报已经称基普乔格为“有史以来最伟大的运动员”。他收获很多冠军，还拿到奥运会金牌，也打破了世界纪录。经济状况良好。即便如此，基普乔格依然维持了自己在肯尼亚训练营的生活，条件堪比苦行僧。 营员们住在非常简陋的合住寝室，使用公共的卫生间，自己从井里打水，轮流打扫卫生，手洗每天换洗的训练服装。他们有严格的作息时间表，吃饭睡觉，互相帮助拉伸和按摩。当太阳升起训练营的选手们开始奔跑，野外的泥路尘土飞扬，犹如非洲动物一场小型的迁徙一般。 每个人每天会跑上几十公里，每周跑量则会惊人的超过两百公里。 训练营的生活基普乔格过了整整19年。跑马拉松后，他的生活越发简单。 很长时间，桑和基普乔格的沟通类似于布置/完成作业，“基普乔格是所有人里最认真执行的。他也会请教我很多，告诉我他自己的理解和分析。”室友说他生活的特别有纪录，不管是吃饭还是睡觉，他总非常按时的进行。另外，“总是第一个到训练场。” 马拉松热潮到来后，体育记者们扛着长枪短炮涌入各个“长跑者小镇”，试图挖出些成功的秘籍。最终的结论，基因天赋也好，环境外因也好，都只是已知结果的假设：他们以最适合自己的方式生活训练，最终取得了成功。 分析过基普乔格的人，说他有最适合马拉松的身体素质，但柔韧性却出人意料的差，挺直膝盖，手指居然无法弯腰触碰到脚趾。以及，每天要喝很多加了糖的茶。 他的微笑不是保护色，是分散痛苦的方式。对手们认为基普乔格有种能力，能将马拉松这样一个并不愉悦的过程变得像一场演出一样，很圆满的呈现出来。 在前辈伯纳德·拉加特眼里，基普乔格还是一个很好的演说家，无论赞助商活动或者专访，基普乔格一直都在思考，说出的话，很少有雷同重复的。 33岁，用了5年时间拿到10个马拉松冠军，包括两个月前在柏林马拉松大幅提升的世界纪录； 32岁，尝试了前无古人的破二挑战； 31岁，时隔8年再一次参加奥运，毫无悬念的拿到金牌； 30岁，甩着鞋垫、一脚血泡的夺冠，而立之年成为公认的马拉松第一人； 28岁，拿下人生第一个马拉松冠军； 27岁，站在运动生涯的岔路口，没有浪费太多时间就做出了决定。 可能他觉得，仅仅拽住当下那些是不够的，自己还是得有个不一样的世界？他一直矜矜业业做了所有该做的，不缺天赋，非常的自律，也一直善于思考。属于基普乔格的时代只是没有确定开启日期——但在选择马拉松后，豁然开朗。 于是在职业生涯的下半场，一个个终将发生的故事，也就水银泻地般兑现出来。 文章出处 埃鲁德·基普乔格：成为传奇","link":"/o/2020/01/04/running/"},{"title":"什么是浅比较","text":"最近在看一个组件的时候看到了 React.pureComponent,官方文档中对他的描述是 1由于PureComponent的shouldeComponentUpdate里，实际是对props/state进行了一个浅对比，所以对于嵌套的对象不适用，没办法比较出来。 shallowCopy在 React 中，shouldComponentUpdate的实现方式为 123if (this._compositeType === CompositeTypes.PureClass) &#123; shouldUpdate = !shallowEqual(prevProps, nextProps) || ! shallowEqual(inst.state, nextState);&#125;可以看到 PureComponent 就是对 props 和 state 的前后状态做的一个浅比较。","link":"/o/2020/01/08/shallow-compare/"},{"title":"源码阅读计划","text":"一直以来受到技术论坛的“荼毒”，要阅读源码。我也就按照很多论坛中说的那样，git clone 一份代码就开始看，结局都不怎么好。主要还是因为以下几种原因： 技术方面说： 语法特性掌握还不够 比如说看到 Reflect.defineProperty、Proxy 等一些日常业务开发中少见的用法时不能很好的理解其中的细节，频繁的中断会降低个人学习体验。 对 JavaScript 这门语言的设计哲学认识还不够 原型链几乎每个前端都知道，要真的问也都能插上几句话。这个东西长时间不看确实会忘， 正如 王福朋这篇经典的文章中提到 的他每次面试前都要看看。但个人认为原型链是 web 前端开发中不多的值得深刻记忆的东西。 构建工具相关的体系 前端开发在最近几年发展迅速，工程化工具也伴随着剧烈变化通常都是 break changes，比如说第一份工作使用 webpack 2.0 进行打包 React，现在我的电脑里还留着一坨关于 webpack 2.0 配置的宝贝。但是第二份工作却是使用 vue 进行开发，有了 vue.config.js 这么好使的玩意儿对 webpack 4.0 生疏也是难免, 毕竟在业务开发中很够用。 再比如说 babel6.0 和 babel 7.0 的区别，按照官网来配置有时候也跑不通。 源代码中有许多工程性质的配置和针对运行时的特殊优化，对构建工具不清不楚看起来自然会很懵逼。 数据结构与算法的缺失 比如 vue keep-alive 的实现方式，如果你不了解 LRU 的话，我想很难去看明白他在做什么。 学习方法和心理来说： 过去相当长的一段时间总有这么一种观点：沉浸在技术论坛有助于我的极速成长，我的技术视野得到了扩展但是针对现阶段的我造成的弊端也足够明显。 持续性 看到新的技术或名词总想去试试，但浅尝辄止的尝试并不能给现阶段的自己带来过多的帮助甚至会带来迷茫，如果真的想把现在所做的事当作一辈子的事业来做的话这种做法显然有些浮躁了。 自信心 看到各种名词、术语、理念、思想自己都不明白经常会给我带来一种深厚的挫败感。从自己走过来的两年再回头看：这些人出于扩展自己的技术影响力也好、分享也好、还是宣传自己也好，很多都是人为的造词或者新瓶装旧酒。 说到这，想起最近发生的一件事： 某司的人力资源领导被优化了，他曾在去年的年底在自媒上发过一篇文章 《行业寒冬之下，为什么被裁的总是你》。 总之作为一个互联网从业者应当具备很强的信息甄别能力。 roadMap 当你迷茫的时候不知道学什么的时候，第一种方法是去看计算机相关书籍，数据结构与算法也好操作系统也好计算机网络也好。 如果你觉得这种方式太枯燥太理论派你更直接一点的话，可以去找相关机构、课程的目录，但是我觉得没有必要去为此付费，按图索骥的按照目录去学习就好。 第一阶段首先从比较小的代码区块看起，比如: 30 seconds of code ramdaJS 之前看ramada的时候遇到一个问题，在 stackoverflow 上提问还收到了作者的回答， 第二阶段第二步：找到了看源码的感觉后，再去看某个类库的源码，比如说redux、moment这种，功能专一同时也兼顾深度。 完全理解 redux 带着问题看React-Redux源码（一万四千字长文预警 第三阶段这时候自己有了一定的基础和感觉了，可以再去看现在mvvm框架实现的原理，也是从单一的功能开始，拆解mvvm框架的通用实现模式，如双向绑定、虚拟dom等，最后实现自己的mini mvvm。 50行代码的MVVM，感受闭包的艺术 不好意思！耽误你的十分钟，让MVVM原理还给你 第四阶段这时候你具备了看react、vue这种框架的能力了，最好还是带着问题去看，比如看react fiber的原理、如何渲染的，setState怎么操作等等。 [React技术内幕] setState的秘密 怎样学习React？当然是自己动手实现一个React啦 但是实际开发中没有这种造轮子的机会，大家的关注点更多还是放在业务上 多端秒开方案、性能优化相关 移动 H5 首屏秒开优化方案探讨 工程化套件（脚手架、开发调试工具、发布管理） 15分钟搭一个企业级脚手架 前端自动化发布实战总结 数据埋点/监控 前端埋点的设计方案 多端融合 多端统一方案 Taro Awesome Flutter：带你从入门到进阶的 Flutter 指南 组件库 pre code low code 互动平台、直播 直播原理与web直播实战 SSR 微前端 一文吃透 React SSR 服务端渲染和同构原理 BFF、Serverless、BFF in Serverless BFF、Serverless、以及BFF in Serverless 灰度平台/ABtest等等 https://juejin.im/post/5da88d795188252f051e2b47 软技能 软技能-代码之外的生存指南1(职业篇) 工程师如何在工作中提升自己? 参考： 路线图大部分参考了知乎中的这篇回答一年经验的前端开发工程师看不懂源码怎么办，","link":"/o/2019/11/21/source/"},{"title":"JavaScript 的运行机制","text":"参考： Philip Roberts 制作的一个实时监控代码中 Event Loop 的监控页面 知乎： JavaScript 中的堆栈 JSConf 2014 Philip Roberts 关于 Event Loop 的解释 阮一峰：Stack 的三种含义","link":"/o/2019/12/08/stack-heap/"},{"title":"Vue 组件的本质是什么","text":"在传统页面开发中，我们使用 模板引擎 进行页面开发， 类似 lodash.template 123456import &#123; template &#125; from &apos;lodash&apos;const compiler = template(&apos;&lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt;&apos;)const html = compiler(&#123; title: &apos;My Component&apos; &#125;)document.getElementById(&apos;app&apos;).innerHTML = html 模板引擎的概念是： 数据 + 模板 =&gt; HTML 我们可以看到 compiler ，接受的参数是 html 字符串，渲染出页面，似乎一个函数就是一个组件。 \b实际上在使用 \bVue 或 React 开发时，他们的输出并不是 html 字符串，而是 Virtual Dom 数据 + 模板 =&gt; Virtual Dom 以 Vue 为例，一个组件的核心其实是 render 函数，其他内容，像 data、computed、props 都是为 render 函数提供服务的。render 函数本可以直接生成 html 但却产出了 virtual dom， 借助 snabbdom 的 API 我们可以表达出这个公式。 123456import &#123; h &#125; from snabbdom// h 函数用来创建 VNode，组件的产出是 VNodeconst MyComponent = props =&gt; &#123; return h(&apos;h1&apos;, props.title)&#125;传统的开发中， \b通过将模板引擎\b直接替换为 html，可是 virtual dom \b毕竟无法直接渲染到浏览器中，把 virtual dom 渲染为 dom 的过程叫做 patch。 123456789101112import &#123; h, init &#125; from &apos;snabbdom&apos;// init 方法用来创建 patch 函数const patch = init([])const MyComponent = props =&gt; &#123; return h(&apos;h1&apos;, props.title)&#125;// 组件的产出是 VNodeconst prevVnode = MyComponent(&#123; title: &apos;prev&apos; &#125;)// 将 VNode 渲染成真实 DOMpatch(document.getElementById(&apos;app&apos;), prevVnode) 数据变更时，组件会产生新的 VNode， 只需要再次调用 patch 1234// 数据变更，产出新的 VNodeconst nextVnode = MyComponent(&#123; title: &apos;next&apos; &#125;)// 通过对比新旧 VNode，高效地渲染真实 DOMpatch(prevVnode, nextVnode) 另外说几点题外话\b\b： 为什么需要使用 virtual dom 为什么要通过 virtual dom曾经一度以为使用 virtual dom 的原因是因为操作 virtual dom 比操作 DOM 的速度快。但其实这是一种错误的认识。 看到 尤雨溪:网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么 这个\b答案的回答可以总结为这几点： 在比较性能的时候，要分清楚初始渲染、小量数据更新、大量数据更新这些不同的场合。 可以渲染到 DOM 以外的 backend，比如 ReactNative。 为函数式的 UI 编程方式打开了大门 本文参考：hcysun 组件的本质是什么","link":"/o/2020/01/10/vue-component/"},{"title":"在前端项目中使用 vuex orm","text":"什么是 ORM网上抄的基本概念：ORM全称是：Object Relational Mapping(对象关系映射)，其主要作用是在编程中，把面向对象的概念跟数据库中表的概念对应起来。举例来说就是，我定义一个对象，那就对应着一张表，这个对象的实例，就对应着表中的一条记录。 为什么我要使用 Vuex ORM之前一直在做公司内部的运维平台 遇到了这几个问题： 1、 接口返回数据过大（最差的一种情况一个接口返回了 10M 的 JSON，需要前端再对这个 JSON 数据进行二次加工渲染图形 这个问题后来使用 web worder 解决） 2、 数据间的交流过多 理想化交互逻辑： 点击左侧树 -&gt; 获取到 集群、服务、机器 选中机器 -&gt; 获取到 metrics 项 选中metrics项 -&gt; 获取到对应指标的数据，通过 echarts 渲染 导致的问题： 每一个获取下一级的接口都需要传递各处不同的参数 该如何设计 Store 结构 ？ 是应当按照直觉 UI = f(state) 还是 应该把数据拍平。 其实按照这两种不同设计理念设计 Store 的话又会存在以下问题： Store 层级过深会不会对性能产生影响 把 Store 拍平的话又该如何去跨域对象层级去获取相关数据 最终还是硬着头皮做完了， 但樯橹灰飞烟灭还是留下了高昂的维护成本、for 循环漫天飞和无尽的心灵伤的伤害 😣。 为什么前端要使用 Vuex ORM在了解了我司几个开发运营后台的同事开发的业务之后其实发现很多业务并不需要状态管理工具。“PS:此刻想起 Dan Abramov 那句名言 “如果你不知道你是否需要 Redux， 那么你一定不需要 Redux“。”而在需要使用状态管理工具的业务中又缺乏一定设计准则 详见知乎讨论：前端开发应更多地使用多层嵌套对象的结构，还是拍平数组进行引用的结构。 这个时候，Vuex ORM 提供一种工业标准可以大大提升代码的可维护性和开发效率，我认为也就是在业务层面上进行领域模型抽象。 优势Vuex Orm 一方面让项目中的 Vuex 使用更加优雅（你不用再去写 this.$store.Home.xxx.xxx 这种链式调用代码）。另一方面前端对接口的承受能力会变得更高，比如说后端没有因为某些原因不能按照我们的想法来提供接口时，除了在 BFF 层做处理外我们可以直接在浏览器中建立数据模型提升开发效率。最后 Vuex Orm 中的数据模型提供了类型判断的能力（就像 TS 一样）降低代码出错率。 定义数据类型模型字段的基本类型 Type 含义 this.attr(“”) 任意值 this.string(“”) 字符串 this.number(“”) 数字 this.boolean(“”) 布尔值 特殊类型 | Type | 含义 || nullable | 空值 || this.increment() | 自增 | 关系类型 数据模型模型间的关系Vuex-Orm 定义了几种关系用来描述数据模型之间的关系 关系 写法 含义 One to One this.hasOne(Profile, ‘user_id’) 一个数据对象拥有一个数据对象 One to One Inverse this.belongTo(User, ‘user_id’) 一个数据模型中包含另一个数据对象 One to One Inverse this.belongTo(User, ‘user_id’) 一个数据模型归属于一个数据对象 One to Many this.belongTo(User, ‘user_id’) 一个数据对象属多种另一个类型的数据对象（归属方） Has Many By this.hasManyBy(Node, ‘user_ids’) 一个数据对象属多种另一个类型的数据对象（被归属方） Many To Many roles: this.belongsToMany(Role, RoleUser, ‘user_id’, ‘role_id’) 角色和用户之间的关系：一个角色拥有多个用户，一个用户同样会拥有多种角色 Has Many Through posts: this.hasManyThrough(Post, User, ‘country_id’, ‘user_id’) 一个村落拥有许多邮政局作为桥梁来互相沟通 One To One (Polymorphic) image: this.morphOne(Image, ‘imageable_id’, ‘imageable_type’) 见下文解释 One To Many (Polymorphic) 见下文解释 Many To Many (Polymorphic) 见下文解释 hasManyThrough 例子12345678this.hasManyThrough( Post, // Final model we wish to access. User, // Intermediate model. &apos;country_id&apos;, // Foreign key on User model. &apos;user_id&apos;, // Foreign key on Post model. &apos;local_country_id&apos;, // Local key on Country model. &apos;local_user_id&apos; // Local key on User model.) morphOne 一张图片可以属于一个用户，也可以属于一个评论。123456789101112131415161718192021222324252627282930313233343536class User extends Model &#123; static entity = &apos;users&apos; static fields () &#123; return &#123; id: this.attr(null), name: this.string(&apos;&apos;), image: this.morphOne(Image, &apos;imageable_id&apos;, &apos;imageable_type&apos;) &#125; &#125;&#125;class Post extends Model &#123; static entity = &apos;posts&apos; static fields () &#123; return &#123; id: this.attr(null), title: this.string(&apos;&apos;), image: this.morphOne(Image, &apos;imageable_id&apos;, &apos;imageable_type&apos;) &#125; &#125;&#125;class Image extends Model &#123; static entity = &apos;images&apos; static fields () &#123; return &#123; id: this.attr(null), url: this.attr(&apos;&apos;), imageable_id: this.attr(null), imageable_type: this.attr(null) &#125; &#125;&#125; One To Many (Polymorphic)123456789101112131415161718192021222324252627282930313233343536class Post extends Model &#123; static entity = &apos;posts&apos; static fields () &#123; return &#123; id: this.attr(null), post_title: this.string(&apos;&apos;), comments: this.morphMany(Comment, &apos;commentable_id&apos;, &apos;commentable_type&apos;) &#125; &#125;&#125;class Video extends Model &#123; static entity = &apos;videos&apos; static fields () &#123; return &#123; id: this.attr(null), video_link: this.string(&apos;&apos;), comments: this.morphMany(Comment, &apos;commentable_id&apos;, &apos;commentable_type&apos;) &#125; &#125;&#125;class Comment extends Model &#123; static entity = &apos;comments&apos; static fields () &#123; return &#123; id: this.attr(null), body: this.attr(&apos;&apos;), commentable_id: this.attr(null), commentable_type: this.attr(null) &#125; &#125;&#125; Many To Many (Polymorphic)123456789101112131415161718192021222324252627282930313233343536373839404142434445class Post extends Model &#123; static entity = &apos;posts&apos; static fields () &#123; return &#123; id: this.attr(null), tags: this.morphToMany(Tag, Taggable, &apos;tag_id&apos;, &apos;taggable_id&apos;, &apos;taggable_type&apos;) &#125; &#125;&#125;class Video extends Model &#123; static entity = &apos;videos&apos; static fields () &#123; return &#123; id: this.attr(null), tags: this.morphToMany(Tag, Taggable, &apos;tag_id&apos;, &apos;taggable_id&apos;, &apos;taggable_type&apos;) &#125; &#125;&#125;class Tag extends Model &#123; static entity = &apos;tags&apos; static fields () &#123; return &#123; id: this.attr(null), name: this.attr(&apos;&apos;) &#125; &#125;&#125;class Taggable extends Model &#123; static entity = &apos;taggables&apos; static fields () &#123; return &#123; id: this.attr(null), tag_id: this.attr(null), taggable_id: this.attr(null), taggable_type: this.attr(null) &#125; &#125;&#125; this.morphedByMany()12345678910111213141516class Tag extends Model &#123; static entity = &apos;tags&apos; static fields () &#123; return &#123; id: this.attr(null), name: this.attr(&apos;&apos;), posts: this.morphedByMany( Post, Taggable, &apos;tag_id&apos;, &apos;taggable_id&apos;, &apos;taggable_type&apos; ), videos: this.morphedByMany( Video, Taggable, &apos;tag_id&apos;, &apos;taggable_id&apos;, &apos;taggable_type&apos; ) &#125; &#125;&#125; 继承数据在没有引入Vuex Orm 之前， 我们往往是通过操作 mutations 来对一个对象进行增、删、改、查，数据关系简单操作起来还行，但是一旦数据结构稍微复杂一些写起来就有些繁琐痛苦来。Vuex Orm 会对 Store 中的数据进行持久化，通过已经定义好的数据模型使得 CURD 更加遍历写法更加优雅。 插入操作视图123456789101112131415&lt;script&gt;import User from &apos;@/models/User&apos;export default &#123; created () &#123; User.insert(&#123; data: [ &#123; id: 1, name: &apos;John&apos; &#125;, &#123; id: 2, name: &apos;Jane&apos; &#125;, &#123; id: 3, name: &apos;Johnny&apos; &#125; ] &#125;) &#125; &#125;&lt;/script&gt; Vuex Store 经过更新后 1234567891011&#123; entities: &#123; users: &#123; data: &#123; 1: &#123; id: 1, name: &apos;John&apos; &#125;, 2: &#123; id: 2, name: &apos;Jane&apos; &#125;, 3: &#123; id: 3, name: &apos;Johnny&apos; &#125; &#125; &#125; &#125;&#125; create 方法和 insert 效果一致，他们的区别是 create 会清空之前的数据是一个全量更新 12345678910111213141516171819202122232425262728293031323334353637383940414243// Let&apos;s say this is the initial State.&#123; entities: &#123; users: &#123; data: &#123; 1: &#123; id: 1, name: &apos;John&apos; &#125; &#125; &#125; &#125;&#125;// `insert` is going to insert a new record, and keep existing data.User.insert(&#123; data: &#123; id: 2, name: &apos;Jane&apos; &#125;&#125;)// State after `insert`.&#123; entities: &#123; users: &#123; data: &#123; 1: &#123; id: 1, name: &apos;John&apos; &#125;, 2: &#123; id: 2, name: &apos;Jane&apos; &#125; &#125; &#125; &#125;&#125;// `create` is going to replace all existing data with new data.User.create(&#123; data: &#123; id: 3, name: &apos;Johnny&apos; &#125;&#125;)// State after `create`.&#123; entities: &#123; users: &#123; data: &#123; 3: &#123; id: 3, name: &apos;Johnny&apos; &#125; &#125; &#125; &#125;&#125; 插入数据模型数据模型1234567891011121314151617181920212223class User extends Model &#123; static entity = &apos;users&apos; static fields () &#123; return &#123; id: this.attr(null), name: this.attr(&apos;&apos;), posts: this.hasMany(Post, &apos;user_id&apos;) &#125; &#125;&#125;class Post extends Model &#123; static entity = &apos;posts&apos; static fields () &#123; return &#123; id: this.attr(null), user_id: this.attr(null), title: this.attr(&apos;&apos;) &#125; &#125;&#125; 插入数据模型12345678910111213141516171819202122232425262728// Create User data with its related Post data.User.insert(&#123; data: &#123; id: 1, name: &apos;John Doe &apos;, posts: [ &#123; id: 1, user_id: 1, title: &apos;Post title 1&apos; &#125;, &#123; id: 2, user_id: 1, title: &apos;Post title 2&apos; &#125; ] &#125;&#125;)// State after `insert`.&#123; entities: &#123; posts: &#123; data: &#123; 1: &#123; id: 1, user_id: 1, title: &apos;Post title 1&apos; &#125; 2: &#123; id: 2, user_id: 1, title: &apos;Post title 2&apos; &#125; &#125; &#125;, users: &#123; data: &#123; 1: &#123; id: 1, name: &apos;John Doe&apos; &#125; &#125; &#125; &#125;&#125; 更新操作根据 primary key 来更新1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div&gt; &lt;label&gt;Name&lt;/label&gt; &lt;input :value=&quot;user.name&quot; @input=&quot;updateName&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import User from &apos;@/models/User&apos;export default &#123; computed: &#123; user () &#123; return User.find(1) &#125; &#125;, methods: &#123; updateName (e) &#123; User.update(&#123; where: 1, data: &#123; name: e.target.value &#125; &#125;) &#125; &#125;&#125;&lt;/script&gt; 根据条件来筛123456789101112131415161718192021222324252627282930// Initial State.&#123; entities: &#123; users: &#123; 1: &#123; id: 1, name: &apos;John&apos;, age: 20, active: false &#125;, 2: &#123; id: 2, name: &apos;Jane&apos;, age: 20, active: false &#125;, 3: &#123; id: 3, name: &apos;Johnny&apos;, age: 30, active: false &#125; &#125; &#125;&#125;// Update via function.User.update(&#123; where: (user) =&gt; &#123; return user.age === 20 &#125;, data: &#123; active: true &#125;&#125;)// State after `update`.&#123; entities: &#123; users: &#123; 1: &#123; id: 1, name: &apos;John&apos;, age: 20, active: true &#125;, 2: &#123; id: 2, name: &apos;Jane&apos;, age: 20, active: true &#125;, 3: &#123; id: 3, name: &apos;Johnny&apos;, age: 30, active: false &#125; &#125; &#125;&#125;","link":"/o/2019/11/19/vuex-orm/"},{"title":"JavaScript 中的线程与 Event Loop","text":"为什么 JavaScript 是单线程众所周知 JavaScript 最开始是被设计运行在浏览器中的脚本语言，从浏览器的功能和特性角度来讲，单线程是最合适的。多个线程操作 DOM 的时候容易出现此类问题：这个 DOM 应该被哪个线程控制的问题？ 因此为了避免问题的复杂性，从诞生开始 JavaScript 就是单线程，这已经成为这门语言的核心特征。 随着硬件资源（具体指的是 CPU 核数）不断提升和业务场景的不断的扩大（密集型计算、游戏），需要充分利用多核能力。 HTML 5 提出 Web Worker 标准， 允许 JavaScript 脚本创建多个线程，但主线程完全控制子线程且子线程没有操作 DOM 的权限, 所以说并没有改变 JavaScript 单线程的本质。 执行栈与任务队列单线程意味着排队，必须按照书写代码的顺序执行下去 A -&gt; B -&gt; C -&gt; D，然而一旦哪一步执行的时间非常长就不得不进行长时间的等待，那么这个时候任务就不得不等着前面的执行完。如果是计算量过大 CPU 忙不过来了倒也好说， 然而这时候 CPU 是闲着的，因为许多任务是比较缓慢的，例如： IO、网络，比如等到有结果才能继续执行。 那么可以把任务分为两种：同步任务（synchronous）、异步任务（asynchronous）。同步任务是指：一个任务执行完后再进行下一个任务，异步任务是说：不进入主线程而进入“任务队列（task queue）“的任务，只有“任务队列“通知主线程某个异步任务可以执行了，该任务才可以执行。 具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。） 1234567（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。（4）主线程不断重复上面的第三步。下图就是主线程和任务队列的示意图。 只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。这个过程会不断重复。 事件和回调函数“任务队列”是事件的队列，IO 设备每完成一项任务，就在“任务队列”中添加一个事件，表示相关的异步任务可以进入“执行栈”了。主线程读取“任务队列”，就是读取里面有哪些事件。 “任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。 所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。 “任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。 Event Loop主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。 上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。 定时器除了放置异步任务的事件，”任务队列”还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫做”定时器”（timer）功能，也就是定时执行的代码。 总之，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。 HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout()。 需要注意的是，setTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。 定时器运行机制setTimeout和setInterval的运行机制，是将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就继续等待。 这意味着，setTimeout和setInterval指定的回调函数，必须等到本轮事件循环的所有同步任务都执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，setTimeout和setInterval指定的任务，一定会按照预定时间执行。 特殊的定时器语句我们经常会看到这么一些语句 setTimeout(fn, 0)，那么他的意思真的是等待 0 秒后立即执行么？ 当然不会，正如上文所说需要等到上文全部执行完, 总之，setTimeout(f, 0)这种写法的目的是，尽可能早地执行f，但是并不能保证立刻就执行f。 应用Node.js 中的 Event Loop 根据上图， Node.js 的运行机制 1234567（1）V8引擎解析JavaScript脚本。（2）解析后的代码，调用Node API。（3）libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。（4）V8引擎再将结果返回给用户。 问题遗留process.nextTick process.setImmediate setTimeout 的区别 引用： Vue 中如何使用 MutationObserver 做批量处理？","link":"/o/2019/11/28/worker/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/o/tags/JavaScript/"},{"name":"函数式 计算机","slug":"函数式-计算机","link":"/o/tags/%E5%87%BD%E6%95%B0%E5%BC%8F-%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"JavaScript Exuction","slug":"JavaScript-Exuction","link":"/o/tags/JavaScript-Exuction/"},{"name":"stackoverflow","slug":"stackoverflow","link":"/o/tags/stackoverflow/"},{"name":"web 安全","slug":"web-安全","link":"/o/tags/web-%E5%AE%89%E5%85%A8/"},{"name":"Linux","slug":"Linux","link":"/o/tags/Linux/"},{"name":"Node","slug":"Node","link":"/o/tags/Node/"},{"name":"git","slug":"git","link":"/o/tags/git/"},{"name":"浏览器","slug":"浏览器","link":"/o/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"线程","slug":"线程","link":"/o/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"browser","slug":"browser","link":"/o/tags/browser/"},{"name":"web安全","slug":"web安全","link":"/o/tags/web%E5%AE%89%E5%85%A8/"},{"name":"项目管理","slug":"项目管理","link":"/o/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"},{"name":"技术视野","slug":"技术视野","link":"/o/tags/%E6%8A%80%E6%9C%AF%E8%A7%86%E9%87%8E/"},{"name":"web security","slug":"web-security","link":"/o/tags/web-security/"},{"name":"web fronted","slug":"web-fronted","link":"/o/tags/web-fronted/"},{"name":"JavaScirpt","slug":"JavaScirpt","link":"/o/tags/JavaScirpt/"},{"name":"Promise","slug":"Promise","link":"/o/tags/Promise/"},{"name":"跑步","slug":"跑步","link":"/o/tags/%E8%B7%91%E6%AD%A5/"},{"name":"javaScript","slug":"javaScript","link":"/o/tags/javaScript/"},{"name":"编码","slug":"编码","link":"/o/tags/%E7%BC%96%E7%A0%81/"},{"name":"Vue","slug":"Vue","link":"/o/tags/Vue/"}],"categories":[]}